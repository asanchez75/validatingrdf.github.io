<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.23">
<link rel="stylesheet" type="text/css" href="bookHtml.css">
<title>Comparing ShEx and SHACL</title>
</head>
<body>
<a href="bookHtml013.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="bookHtml015.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<h1 class="chapter" id="sec196">Chapter 7  Comparing ShEx and SHACL</h1>
<p> 
<a id="ch070Comparing"></a>
<a id="ch7"></a></p><p>In this chapter we present a comparison between ShEx and SHACL.
The technologies have similar goals and similar features.
In fact at the start of the Data Shapes Working Group in 2014, 
convergence on a unified approach was considered possible.
However, this did not happen and as of July 2017 both technologies are maintained as separate solutions.</p><p>We start by describing some of the common features that they share, followed by a review of the main differences.</p>
<h2 class="section" id="sec197">7.1  Common Features</h2>
<p>
<a id="ch7.sec1"></a></p><p>ShEx and SHACL share the same goal, to have a mechanism for describing and validating RDF data using a high-level language, so there are a lot of common features that both share. </p><ul class="itemize"><li class="li-itemize"><span class="c014">Shapes</span>. Both define the notion of a shape, as something that contains constraints on the topology of RDF nodes. 
SHACL shapes are similar to ShEx shape expressions, with the difference that links to data nodes are expressed in SHACL by target declarations and in ShEx by shape maps.
In most of the common cases, it is possible to translate between ShEx and SHACL. <div class="example"><div class="theorem"><span class="c014">Example 160</span> <span class="c014">(Similarities between ShEx and SHACL)</span>  <em> 
</em><a id="ch060SimilarShExSHACL"></a><p><em>Consider the following SHACL shapes graph:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:User</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:gender</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:or</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">    [ </span></em><em><span class="c012">sh:in</span></em><em><span class="c012"> (</span></em><em><span class="c012">schema:Male</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:Female</span></em><em><span class="c012">) ]</span></em><em><span class="c012">
</span></em><em><span class="c012">    [ </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012">]</span></em><em><span class="c012">
</span></em><em><span class="c012">   )</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:birthDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>This can be expressed in a ShEx schema:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:User</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">IRI</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012">      </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:gender</span></span></em><em><span class="c012">    [</span></em><em><span class="c012"><span class="c007">schema:Male</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:Female</span></span></em><em><span class="c012">] </span></em><em><span class="c012"><span class="c007">OR</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:birthDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> ?</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table></div></div></li><li class="li-itemize"><span class="c014">Node constraints.</span> Both languages have the notion of node constraints and share similar expressiveness: 
node kinds, datatypes, datatype facets, value sets, etc. 
Example <a href="#ch060SimilarShExSHACL">160</a> shows two declarations which are equivalent in ShEx and SHACL: 
a node must be an IRI, 
have exactly one value for the property 
<code>schema:name</code> that has datatype 
<code>xsd:string</code>, 
have exactly one value for the property 
<code>schema:gender</code> which must be one of (
<code>schema:Male</code><code> </code><code>schema:Female</code>) or a 
<code>xsd:string</code>, 
and optionally have a value for the property 
<code>schema:birthDate</code> that has datatype 
<code>xsd:date</code>.</li><li class="li-itemize"><span class="c014">Property Constraints.</span> 
Both languages enable the declaration of constraints on the outgoing and incoming properties of a node.<div class="example"><div class="theorem"><span class="c014">Example 161</span> <span class="c014">(Constraints on incoming/outgoing properties in ShEx/SHACL)</span>  <em> 
</em><a id="ch060IncomingOutgoing"></a><p><em>The following SHACL shapes graph describes that nodes that conform to </em><em>
</em><code><em>:User</em></code><em> have one outgoing property </em><em>
</em><code><em>schema:name</em></code><em> and one incoming property </em><em>
</em><code><em>schema:member</em></code><em> from an organization.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:User</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> [ </span></em><em><span class="c012">sh:inversePath</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:member</span></em><em><span class="c012"> ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1; </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:node</span></em><em><span class="c012"> </span></em><em><span class="c012">:Organization</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:Organization</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">rdf:type</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1; </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012">:Organization</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>can be expressed in ShEx as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:User</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012">    </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ^</span></em><em><span class="c012"><span class="c007">schema:member</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:Organization</span></span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:Organization</span></span></em><em><span class="c012"> { </span></em><em><span class="c012"><span class="c007">a</span></span></em><em><span class="c012"> [</span></em><em><span class="c012"><span class="c007">:Organization</span></span></em><em><span class="c012">] }</span></em></td></tr>
</table><p><em>Given the following data: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:alice</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:User</span></em><em><span class="c012"> ;                  </span></em><span class="c012"><em><span class="c012"># \Passes{:User} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">       </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Alice"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:bob</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:User</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">       </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Robert"</span></em></span></em><em><span class="c012"> .     </span></em><span class="c012"><em><span class="c012"># \Fails{:User} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:myCompany</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Organization</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">           </span></em><em><span class="c012">schema:member</span></em><em><span class="c012"> </span></em><em><span class="c012">:alice</span></em><em><span class="c012"> .</span></em></td></tr>
</table><p><em>Both ShEx and SHACL check that </em><em>
</em><code><em>:alice</em></code><em> conforms to the </em><em>
</em><code><em>:User</em></code><em> shape 
and raise an error for </em><em>
</em><code><em>:bob</em></code><em> because there is no arc </em><em>
</em><code><em>schema:member</em></code><em> from a node with shape </em><em>
</em><code><em>:Organization</em></code><em> pointing to </em><em>
</em><code><em>:bob</em></code><em>.</em></p></div></div></li><li class="li-itemize"><span class="c014">Cardinalities</span>. Both languages can constraint the number of values for a
property in a specific range, or leave the maximum number of value unbound.</li><li class="li-itemize"><span class="c014">RDF syntax</span>. Both ShEx and SHACL can use RDF concrete syntaxes
though with different vocabularies.</li><li class="li-itemize"><span class="c014">Logical operators</span>. Both ShEx and SHACL have the logical operators And, Or and Not. 
ShEx has the operators <code>|</code> to represent “oneOf” while SHACL has 
<code>xone</code> to represent exactly one.<div class="example"><div class="theorem"><span class="c014">Example 162</span> <span class="c014">(Example with logical operators)</span>  <em> 
</em><a id="ch060AndOrNot"></a><p><em>Imagine that in some domain, a </em><em>
</em><code><em>:Product</em></code><em> must have a </em><em>
</em><code><em>schema:productID</em></code><em> 
with a value that either starts by </em><em>
</em><code><em>P</em></code><em> (matches regular expression </em><em>
</em><code><em><code><em>"^P"</em></code></em></code><em>)
or ends by a digit (regular expression </em><code><em>"\\[0-9]$"</em></code><em>) and is not </em><em>
</em><code><em><code><em>"P23"</em></code></em></code><em>.</em></p><p><em>It can be expressed in ShEx as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Product</span></span></em><em><span class="c012"> ({</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productID</span></span></em><em><span class="c012"> /^</span></em><em><span class="c012"><span class="c007">P</span></span></em><em><span class="c012">/</span></em><em><span class="c012"><span class="c007">i</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">} </span></em><em><span class="c012"><span class="c007">OR</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productID</span></span></em><em><span class="c012"> /[0-9]</span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">/ ;</span></em><em><span class="c012">
</span></em><em><span class="c012">}) </span></em><em><span class="c012"><span class="c007">AND</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">NOT</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productID</span></span></em><em><span class="c012"> [ </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"P23"</span></em></span></span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>and in SHACL as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:ProductShape</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:targetClass</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:or</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1; </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^P"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:flags</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"i"</span></em></span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1; </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"[0-9]$"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012"> );</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:not</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"P23"</span></em></span></em><em><span class="c012">
</span></em><em><span class="c012"> ]  .</span></em></td></tr>
</table><p><em>Given the following data: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:p45</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;             </span></em><span class="c012"><em><span class="c012"># \Passes{:Product} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"P45"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:x23</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;             </span></em><span class="c012"><em><span class="c012"># \Passes{:Product} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"X23"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:p23</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;             </span></em><span class="c012"><em><span class="c012"># \Fails{:Product} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"P23"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:xx</span></em><em><span class="c012">  </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;             </span></em><span class="c012"><em><span class="c012"># \Fails{:Product} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productID</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"xx"</span></em></span></em><em><span class="c012"> .</span></em></td></tr>
</table></div></div></li><li class="li-itemize"><span class="c014">Extension mechanism</span>. Both ShEx and SHACL have extension mechanisms that support the declaration of more advanced constraints.
ShEx has semantic actions (see Section <a href="bookHtml011.html#ch040SemanticActions">4.10</a>)
and SHACL has SHACL-SPARQL (see Section <a href="bookHtml012.html#ch050SHACLSPARQL">5.16</a>).
In Section <a href="#ch070ComparingExtensionMechanism">7.18</a>, we compare the ShEx and SHACL extension mechanisms in more detail.</li></ul>
<h2 class="section" id="sec198">7.2  Syntactic Differences</h2>
<p>
<a id="ch7.sec2"></a></p><p><a id="hevea_default811"></a> <a id="hevea_default812"></a> <a id="hevea_default813"></a> <a id="hevea_default814"></a>
The design of ShEx emphasized human readability, with a compact grammar that follows traditional language design principles and a compact syntax evolved from Turtle.
The specification defines an abstract syntax. The compact syntax (ShExC), a concrete JSON syntax (ShExJ), or any of the concrete syntaxes for RDF may be used to express a ShEx schema.</p><p>SHACL uses the RDF abstract syntax and concrete syntaxes directly. 
The SHACL specification enumerates circa 120 rules that define what constitutes a well-formed SHACL shapes graph.<sup><a id="text57" href="#note57">1</a></sup> 
SHACL processors can simply omit ill-formed shapes graphs.</p><p>A compact syntax inspired by ShEx has been proposed for a subset of SHACL as a WG Note 
(see Section <a href="bookHtml012.html#ch050SHACLC">5.18</a>) 
but it is not mandatory, and compliant SHACL processors are only required to handle the RDF syntax.</p><p><a id="hevea_default815"></a> 
As the SHACL compact syntax was inspired by ShExC, they look similar, but there are several semantic differences.</p><div class="example"><div class="theorem"><span class="c014">Example 163</span>  <em>Comparing ShEx and SHACL compact syntaxes</em><em> 
</em><a id="ch060ShExSHACLCompactExample"></a><p><em>Given the following ShEx schema:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Product</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012"> /^[</span></em><em><span class="c012"><span class="c007">A</span></span></em><em><span class="c012">-</span></em><em><span class="c012"><span class="c007">R</span></span></em><em><span class="c012">]/ ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012"> /^[</span></em><em><span class="c012"><span class="c007">M</span></span></em><em><span class="c012">-</span></em><em><span class="c012"><span class="c007">Z</span></span></em><em><span class="c012">]/ ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:brand</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">IRI</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:Organization</span></span></em><em><span class="c012">* ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:purchaseDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> ?</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:Organization</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>A similar (but not equivalent) representation using SHACL compact syntax is: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Product</span></span></em><em><span class="c012"> {</span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012">    </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> [1..1] </span></em><em><span class="c012"><span class="c007">pattern</span></span></em><em><span class="c012">=</span></em><em><span class="c012"><span class="c005"><em><span class="c012">"^[A-R]"</span></em></span></span></em><em><span class="c012"> .</span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012">    </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> [1..1] </span></em><em><span class="c012"><span class="c007">pattern</span></span></em><em><span class="c012">=</span></em><em><span class="c012"><span class="c005"><em><span class="c012">"^[M-Z]"</span></em></span></span></em><em><span class="c012"> .</span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:brand</span></span></em><em><span class="c012">        </span></em><em><span class="c012"><span class="c007">IRI</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:Organization</span></span></em><em><span class="c012"> [0..*] .</span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:purchaseDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> [0..1] </span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012">}</span></em><em><span class="c012"><span class="c007">
:Organization</span></span></em><em><span class="c012"> {</span></em><em><span class="c012"><span class="c007">
</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string
</span></span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>Though the examples look similar on the surface, there are several subtle differences. 
The ShEx schema says that there must be two values for the property </em><em>
</em><code><em>
schema:productId</em></code><em>, 
one matching </em><em>
</em><code><em><code><em>"^[A-R]"</em></code></em></code><em> and the other matching </em><em>
</em><code><em><code><em>"^[M-Z]"</em></code></em></code><em>. 
In contrast, the SHACL shapes graph says that there is only one property </em><em>
</em><code><em>schema:productId</em></code><em>, 
which must satisfy both regular expressions.</em></p><p><em>Given the following RDF data:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:p1</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;                   </span></em><span class="c012"><em><span class="c012"># \Passes{:Product using ShEx} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"AB"</span></em></span></em><em><span class="c012">  ;       </span></em><span class="c012"><em><span class="c012"># \Fails{:Product using SHACL} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"XY"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">schema:brand</span></em><em><span class="c012">     </span></em><em><span class="c012">:myBrand</span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:p2</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;                   </span></em><span class="c012"><em><span class="c012"># \Fails{:Product using ShEx} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"MON"</span></em></span></em><em><span class="c012"> ;       </span></em><span class="c012"><em><span class="c012"># \Passes{:Product using SHACL} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">schema:brand</span></em><em><span class="c012">     </span></em><em><span class="c012">:myBrand</span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:myBrand</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"MyBrand"</span></em></span></em><em><span class="c012"> .</span></em></td></tr>
</table><p><em>Node </em><em>
</em><code><em>:p1</em></code><em> conforms to ShEx definition of </em><em>
</em><code><em>:Product</em></code><em> and does not conform to SHACL because the constraints on </em><em>
</em><code><em>schema:productId</em></code><em> are not satisfied (both must be satisfied). 
Node </em><em>
</em><code><em>:p2</em></code><em> does not conform to ShEx because it only has one </em><em>
</em><code><em>schema:productId</em></code><em> but conforms to SHACL because it satisfies all constraints.
</em></p></div></div><p>The RDF vocabulary of ShEx is also different from SHACL. </p><div class="example"><div class="theorem"><span class="c014">Example 164</span>  <p><em>The RDF representation of Example </em><a href="#ch060ShExSHACLCompactExample"><em>163</em></a><em> in ShEx is:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012">  </span></em><em><span class="c012">a</span></em><em><span class="c012">     </span></em><em><span class="c012">sx:Shape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:expression</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:EachOf</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:expressions</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:TripleConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:predicate</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:valueExpr</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:NodeConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">                   </span></em><em><span class="c012">sx:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^[A-R]"</span></em></span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:TripleConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:predicate</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:valueExpr</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:NodeConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">                   </span></em><em><span class="c012">sx:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^[M-Z]"</span></em></span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:TripleConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:predicate</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:brand</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:min</span></em><em><span class="c012"> 0; </span></em><em><span class="c012">sx:max</span></em><em><span class="c012"> -1;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:valueExpr</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:ShapeAnd</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sx:expressions</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">       [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:NodeConstraint</span></em><em><span class="c012">; </span></em><em><span class="c012">sx:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:iri</span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">       </span></em><em><span class="c012">:Organization</span></em><em><span class="c012">
</span></em><em><span class="c012">      )</span></em><em><span class="c012">
</span></em><em><span class="c012">    ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:TripleConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:predicate</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:purchaseDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:min</span></em><em><span class="c012"> 0 ; </span></em><em><span class="c012">sx:max</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sx:valueExpr</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sx:NodeConstraint</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">                  </span></em><em><span class="c012">sx:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012"> )</span></em><em><span class="c012">
</span></em><em><span class="c012">] .</span></em></td></tr>
</table><p><em>Here is the RDF encoding of the SHACL shapes graph in 
Example </em><a href="#ch060ShExSHACLCompactExample"><em>163</em></a><em>:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012">  </span></em><em><span class="c012"><em><span class="c012">"^[A-R]"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012">  </span></em><em><span class="c012"><em><span class="c012">"^[M-Z]"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:brand</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:node</span></em><em><span class="c012">     </span></em><em><span class="c012">:Organization</span></em><em><span class="c012">
</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:purchaseDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012">
</span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">.</span></em></td></tr>
</table></div></div>
<h2 class="section" id="sec199">7.3  Foundation: Schema vs. Constraints</h2>
<p>
<a id="ch7.sec3"></a></p><p>Although both languages share a common goal, their designs are based on different approaches.</p><p>The designers of ShEx intended the language to be like a grammar or schema for RDF graphs. 
This design was inspired by languages such as Yacc, RelaxNG, and XML Schema. 
The main goal was to describe RDF graph structures so they could be validated against those descriptions.</p><p><a id="hevea_default816"></a> <a id="hevea_default817"></a> <a id="hevea_default818"></a>
In contrast, the designers of SHACL aimed at providing a constraint language for RDF. 
The main goal of SHACL is to verify that a given RDF graph satisfies a collection of constraints. 
<a id="hevea_default819"></a>
In this sense, SHACL follows the Schematron approach, applied to RDF: it declares constraints that RDF graphs must fulfill. 
Just as Schematron relies strongly on XPath, SHACL relies strongly on SPARQL.</p><p>This difference is reflected in how validation results fit in.
ShEx implementations usually construct a data structure representing the RDF graph that were validated, containing the nodes and shapes that were matched. 
<a id="hevea_default820"></a> <a id="hevea_default821"></a>
After ShEx validation, the result shape map contains a structure which can be considered as an 
annotated graph that can be traversed or used for further actions, 
such as transforming RDF graphs into other data structures.
This structure is analogous to the Post Schema Validation Infoset from XML Schema (see Section <a href="bookHtml010.html#ch030PSVI">3.1.3</a>).</p><p>In contrast, SHACL describes in detail the errors returned when constraints are not satisfied. 
A SHACL validation report (see Section <a href="bookHtml012.html#ch050ValidationReport">5.5</a>) can be very useful for detecting and repairing errors in RDF graphs. 
When there are no errors, SHACL processors usually report a single value, 
<code>sh:conformance</code><code> </code><code>true</code>.
With SHACL, it can be difficult for users to distinguish the case in which a node 
is valid because it was checked against some shape, versus the case in which a node
is not valid but was ignored by the SHACL processor because it was not reached during the validation process.</p><p>The SHACL recommendation prescribes a basic structure for each violation result
but does not prescribe what information is to be returned when a node is validated.
Nevertheless, SHACL processors can enrich their results.
<a id="hevea_default822"></a>
Shaclex, for example, returns information about the nodes validated.</p>
<h2 class="section" id="sec200">7.4  Invoking Validation</h2>
<p>
<a id="ch7.sec4"></a></p><p>SHACL shapes can include target declarations that associate each shape with a set of RDF nodes and tell SHACL processors how to trigger the validation process
(see Section <a href="bookHtml012.html#ch050TargetNodes">5.7</a>). </p><div class="example"><div class="theorem"><span class="c014">Example 165</span>  <em>Target declarations and SHACL invocation</em><em> 
</em><a id="ch060InvokingValidationSHACL"></a><p><em>Consider the following SHACL shapes graph:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShape</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:targetClass</span></em><em><span class="c012">      </span></em><em><span class="c012">:User</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:targetObjectsOf</span></em><em><span class="c012">  </span></em><em><span class="c012">schema:member</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:targetSubjectsOf</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:familyName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:targetNode</span></em><em><span class="c012">       </span></em><em><span class="c012">:alice</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">] .</span></em></td></tr>
</table><p><em>and the following RDF graph:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:alice</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Alice"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:bob</span></em><em><span class="c012">       </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:User</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">           </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Robert"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:myCompany</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:member</span></em><em><span class="c012"> </span></em><em><span class="c012">:carol</span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:carol</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Carol"</span></em></span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:dave</span></em><em><span class="c012">      </span></em><em><span class="c012">schema:familyName</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Smith"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">           </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Dave Smith"</span></em></span></em><em><span class="c012"> .</span></em></td></tr>
</table><p><em>A SHACL processor checks that </em><em>
</em><code><em>:alice</em></code><em>, </em><em>
</em><code><em>:bob</em></code><em>, </em><em>
</em><code><em>:carol</em></code><em>, and </em><em>
</em><code><em>:dave</em></code><em> conform to </em><em>
</em><code><em>:UserShape</em></code><em>.</em></p><p><em>Directly associating target declarations to shapes can become quite verbose 
(see Section </em><a href="bookHtml013.html#ch070ShaclInShacl"><em>6.6</em></a><em>). 
At the same time, it can limit the reusability of a shape in other contexts. 
In the example above, if we import </em><em>
</em><code><em>:UserShape</em></code><em> in another context where the node </em><em>
</em><code><em>:alice</em></code><em> represents a product instead of a user, the SHACL processor will still try to validate the node with that shape. 
</em><a id="hevea_default823"></a><em>
To avoid such cases, SHACL provides the </em><em>
</em><code><em>sh:deactivated</em></code><em> directive 
(see Section </em><a href="bookHtml012.html#ch050DeactivatingShapes"><em>106</em></a><em>).
</em></p></div></div><p>While including the target declarations in the schema is a convenient way to trigger validation, it can be considered an anti-pattern because the shape can’t be reused for other data.
Even though this could work in some closed systems, it is impractical for data in open environments.
In the interest of keeping schemas reusable, it is a good practice for SHACL 
to place target declarations in a separate file and link this file to the schema with 
<code>owl:imports</code>.</p><p>A ShEx schema declares a constellation of shape expressions that function as a grammar against which RDF nodes can be tested. 
The schema itself provides no mechanism for associating a shape expression with the nodes to which the schema applies.
In the interest of making schemas reusable, ShEx requires that definitions of shapes be decoupled from their application to particular RDF graphs. 
ShEx separates the language of schemas, on the one hand, from the association of shapes with nodes to be validated, on the other, by introducing the notion of shape maps
(see Section <a href="bookHtml011.html#ch040ShapeMaps">4.9</a> for more details).
This separation of concerns encourages the community to innovate on node-shape association mechanisms independently from the validation semantics.
For example, though the shape map specification currently only supports RDF nodes by direct reference or by triple pattern, Wikidata versions of ShEx include support for SPARQL queries over remote endpoints.
As such conventions evolve they can be rolled into future versions of the shape map specification.</p><div class="example"><div class="theorem"><span class="c014">Example 166</span>  <em>Invoking validation through Shape maps in ShEx</em><p><em>The SHACL shapes graph from Example </em><a href="#ch060InvokingValidationSHACL"><em>165</em></a><em> can be expressed in ShEx with the following query shape map:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">{ </span></em><em><span class="c012"><span class="c007">FOCUS</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">rdf:type</span></span></em><em><span class="c012">      </span></em><em><span class="c012"><span class="c007">:User</span></span></em><em><span class="c012"> }</span></em><em><span class="c012"><span class="c007">@:UserShape,</span></span></em><em><span class="c012">
</span></em><em><span class="c012">{ </span></em><em><span class="c012"><span class="c007">_</span></span></em><em><span class="c012">     </span></em><em><span class="c012"><span class="c007">schema:member</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">FOCUS</span></span></em><em><span class="c012"> }</span></em><em><span class="c012"><span class="c007">@:UserShape,</span></span></em><em><span class="c012">
</span></em><em><span class="c012">{ </span></em><em><span class="c012"><span class="c007">FOCUS</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:familyName</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">_</span></span></em><em><span class="c012"> }</span></em><em><span class="c012"><span class="c007">@:UserShape,</span></span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:alice</span></span></em><em><span class="c012">                       </span></em><em><span class="c012"><span class="c007">@:UserShape</span></span></em></td></tr>
</table><p><em>and removing the target declarations from the shape definition:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>The declarations above behave similarly to the SHACL target declarations. 
One subtle difference is that while in the previous case, ShEx only checks direct instances of </em><em>
</em><code><em>:User</em></code><em>, 
SHACL applies the concept of SHACL instance, which also encompass instances of subclasses of </em><em>
</em><code><em>:User</em></code><em>. 
This possibility can be expressed using property paths in shape maps as: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">{ </span></em><em><span class="c012"><span class="c007">FOCUS</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">rdf:type</span></span></em><em><span class="c012">/</span></em><em><span class="c012"><span class="c007">rdfs:subClassOf</span></span></em><em><span class="c012">* </span></em><em><span class="c012"><span class="c007">:User</span></span></em><em><span class="c012"> }</span></em><em><span class="c012"><span class="c007">@:UserShape</span></span></em></td></tr>
</table></div></div><p>Another notable difference between SHACL target node declarations and ShEx shape maps is the following:
when a declared target node in SHACL does not exist in the data graph and there are no required values for this node in the shape, the node passes the validation. In ShEx if the node does not exit it always results in a failure, no matter of the shape definition.</p>
<h2 class="section" id="sec201">7.5  Modularization and Reusability</h2>
<p>
<a id="ch7.sec5"></a></p><p>SHACL leverages the property 
<code>owl:imports</code> to enable a shapes graph to import other shapes graphs. 
This mechanism, which can be used to provide the basis of a modular design, is described in Section <a href="bookHtml012.html#ch050ImportingShapes">5.4</a>.</p><p>ShEx has the concept of 
<code>shapeExternal</code> to declare that the contents of a shape can be obtained from an external source (see Section <a href="bookHtml011.html#ch040.ExternalShapes">4.7.3</a>).</p><p>ShEx has a basic import mechanism which allows a schema to derefentiate another schema (see section <a href="bookHtml011.html#ch040ImportMechanism">4.12</a>) 
while SHACL has also the possibility to import other shapes graphs using 
<code>owl:imports</code> (see section <a href="bookHtml012.html#ch050ImportingShapes">5.4</a>). 
One difference between ShEx and SHACL import mechanisms is that ShEx dereferentiates the schema while SHACL is a graph merge, 
so in SHACL the system expects to have already fetched all of the relevant shapes graphs.</p><p>Both languages support the reuse of shapes through extending a shape with an 
<code>AND</code> operator, as described in 
Section <a href="bookHtml011.html#ch040ReusingShapesShEx">4.8.1</a> 
(ShEx) and Section <a href="bookHtml012.html#ch050ExtendingShapesSHACL">127</a> (SHACL). </p><div class="example"><div class="theorem"><span class="c014">Example 167</span>  <em>Extending shapes in ShEx and SHACL</em><p><em>As a simple example, the following ShEx schema declares a </em><em>
</em><code><em>:Product</em></code><em> shape and a </em><em>
</em><code><em>:SoldProduct</em></code><em> shape:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Product</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012"><span class="c007">schema:price</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:decimal</span></span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:SoldProduct</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:Product</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">AND</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:purchaseDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:productId</span></span></em><em><span class="c012"> /^[</span></em><em><span class="c012"><span class="c007">A</span></span></em><em><span class="c012">-</span></em><em><span class="c012"><span class="c007">Z</span></span></em><em><span class="c012">]/</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>A </em><em>
</em><code><em>:SoldProduct</em></code><em> has the same constraints as the </em><em>
</em><code><em>:Product</em></code><em> plus two more constraints.
One that further restricts the property </em><em>
</em><code><em>schema:productId</em></code><em> and another one that requires a new property </em><em>
</em><code><em>schema:purchaseDate</em></code><em>.</em></p><p><em>Here is an analogous SHACL shapes graph:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ];</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:price</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:decimal</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ].</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:SoldProduct</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012"><span class="c010">sh:and</span></span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">:Product</span></em><em><span class="c012">
</span></em><em><span class="c012">    [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:purchaseDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    ]</span></em><em><span class="c012">
</span></em><em><span class="c012">    [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^[A-Z]"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ) .</span></em></td></tr>
</table><p><em>Another way to reuse shapes in SHACL is by leveraging the subclass relationship and the corresponding target declarations.
The example above could be expressed as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape,</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c010">rdfs:Class</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">  ];</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:price</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:decimal</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">  ].</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:SoldProduct</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape,</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c010">rdfs:Class</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">rdfs:subClassOf</span></em><em><span class="c012"> </span></em><em><span class="c012">:Product</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:purchaseDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:productId</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^[A-Z]"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">.</span></em></td></tr>
</table><p><em>In this approach, </em><em>
</em><code><em>:SoldProduct</em></code><em> is declared as subclass of </em><em>
</em><code><em>:Product</em></code><em>. 
The </em><em>
</em><code><em>rdfs:Class</em></code><em> declaration establishes that all nodes of </em><em>
</em><code><em>rdf:type</em></code><em> </em><em>
</em><code><em>:SoldProduct</em></code><em> must conform to shape </em><em>
</em><code><em>:SoldProduct</em></code><em> and also to </em><em>
</em><code><em>:Product</em></code><em>.</em></p><p><em>One limitation of this approach is that it requires nodes to have an 
the appropriate </em><em>
</em><code><em>rdf:type</em></code><em> declaration as well as keep
</em><em>
</em><code><em>rdfs:subClassOf</em></code><em> statements in the data graph.</em></p></div></div><p>The reusability of both languages could be improved. 
For example, there is no notion of a module, where one might declare internal or hidden shapes, or of public shapes that could be imported by other modules. 
Also, there is no notion of a shape extending other shape, inheriting some properties and redefining others.
Such features could potentially be developed for both languages.</p>
<h2 class="section" id="sec202">7.6  Shapes, Classes, and Inference</h2>
<p>
<a id="ch7.sec6"></a></p><p>ShEx is only concerned with RDF graphs as they are presented to the validator. 
There is no interaction between the ShEx processor and any inference mechanism. 
In this way, ShEx can be used before or after inference. 
It can even be used to validate the behavior of an inference engine if one defines the shapes that an RDF graph must have before and after inference (see an example in Section <a href="bookHtml011.html#ch040ShExInference">4.11</a>).</p><p>In contrast, SHACL has some mechanisms that may interact with inference. 
For example, the implicit class target (see Section <a href="bookHtml012.html#ch050implicitTargetClass">5.7.3</a>),
which associates a shape with a class, triggers validation on all nodes that are 
SHACL instances.
The notion of SHACL instance is different to the RDF Schema notion of instance because it encompasses instances 
of a class plus its sub-classes (as determined by following 
<code>rdfs:subClassOf</code> links in the data), but does 
not take into account all RDFS elements. </p><p>The results of applying a SHACL validator may be different if applied to RDF graphs before or after RDFS inference. 
As SHACL processors are not required to support full RDFS inference, they may ignore other RDFS predicates, such as

<code>rdfs:domain</code>, 
<code>rdfs:range</code>, and sub-properties of 
<code>rdfs:subClassOf</code>.</p><p>For example, consider the following SHACL shape:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:targetClass</span><span class="c012"> </span><span class="c012">:User</span><span class="c012"> .</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:name</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1 ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:string</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">  ] .</span></td></tr>
</table><p>and the following RDF data:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:Teacher</span><span class="c012"> </span><span class="c012">rdfs:subClassOf</span><span class="c012"> </span><span class="c012">:User</span><span class="c012"> .</span><span class="c012">
</span><span class="c012">:teaches</span><span class="c012"> </span><span class="c012">rdfs:domain</span><span class="c012"> </span><span class="c012">:Teacher</span><span class="c012"> .</span><span class="c012">
</span><span class="c012">
</span><span class="c012">:frank</span><span class="c012"> </span><span class="c012">:teaches</span><span class="c012"> </span><span class="c012">:Algebra</span><span class="c012"> ;    </span><span class="c012"><em><span class="c012"># Ignored without RDFS inference *)</span></em></span><span class="c012">
</span><span class="c012">       </span><span class="c012">schema:name</span><span class="c012"> </span><span class="c012"><span class="c012">"Frank"</span></span><span class="c012"> .  </span><span class="c012"><em><span class="c012">#\Passes{:UserShape with RDFS inference} *)</span></em></span><span class="c012">
</span><span class="c012">
</span><span class="c012">:grace</span><span class="c012"> </span><span class="c012">:teaches</span><span class="c012"> </span><span class="c012">:Logic</span><span class="c012"> ;      </span><span class="c012"><em><span class="c012"># Ignored without RDFS inference *)</span></em></span><span class="c012">
</span><span class="c012">       </span><span class="c012">schema:name</span><span class="c012"> 34 .       </span><span class="c012"><em><span class="c012">#\Fails{:UserShape with RDFS inference} *)</span></em></span><span class="c012">
</span><span class="c012">
</span><span class="c012">:oscar</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">:Teacher</span><span class="c012"> ;           </span><span class="c012"><em><span class="c012">#\Fails{:UserShape} *)</span></em></span><span class="c012">
</span><span class="c012">       </span><span class="c012">schema:name</span><span class="c012"> 45 .</span></td></tr>
</table><p><a id="hevea_default824"></a>
If SHACL is applied after RDFS inference, the system checks whether 
<code>:frank</code> and 
<code>:grace</code> conform to 
<code>:UserShape</code>. 
This is because the domain declaration of 
<code>:teaches</code> allows RDFS to infer that they are instances of 
<code>:Teacher</code> and, hence, instances of 
<code>:User</code>, with the following results:</p><ul class="itemize"><li class="li-itemize">
<code>:grace</code> has a value for 
<code>schema:name</code> that is not an 
<code>xsd:string</code>.</li><li class="li-itemize">
<code>:oscar</code> has a value for 
<code>schema:name</code> that is not an 
<code>xsd:string</code>.</li></ul><p>In contrast, if SHACL is applied without RDFS inference, the system returns only one error:</p><ul class="itemize"><li class="li-itemize">

<code>:oscar</code> has a value for 
<code>schema:name</code> that is not an 
<code>xsd:string</code>.
</li></ul><p>The system does not check 
<code>:frank</code> or 
<code>:grace</code> against shape 
<code>:User</code> because it only follows 
<code>rdf:type</code> and 
<code>rdfs:subClassOf</code> declarations. 
In the absence of RDFS inference, the system only checks that 
<code>:oscar</code> has shape 
<code>:User</code>. If SHACL is applied after RDFS inference, the system checks the additional nodes.</p><p>This interference between SHACL and RDFS semantics hampers the use of SHACL to validate an inference system as the use case described for ShEx in 
Example <a href="bookHtml010.html#ch040%3AexampleInference">21</a>.</p><p><a id="hevea_default825"></a>
The property 
<code>sh:entailment</code> can be used to declare that the SHACL processors should add inferred triples during validation to the data graph following the inference rules declared by a given entailment regime (see Section <a href="bookHtml012.html#ch050SHACLINFERENCE">5.17</a>).
Nevertheless, SHACL processors are not required to support entailment regimes. 
If a shapes graph declares an entailment and the processor does not support it, a failure must be signalled.</p>
<h2 class="section" id="sec203">7.7  Violation Reporting and Severities</h2>
<p>
<a id="ch7.sec7"></a></p><p>As pointed out above, SHACL puts more emphasis on validation and provides a dedicated RDF vocabulary for describing conformance and reporting detailed violation results.</p><p><a id="hevea_default826"></a>
For every focus node that does not conform to a shape, an instance of 
<code>sh:ViolationResult</code> is created in the SHACL results graph.
Each violation result links back to the focus node along with metadata, which includes the shape IRI, human readable messages, the failed constraint, the path, and (when available) the value node.
<a id="hevea_default827"></a>
<a id="hevea_default828"></a>
The severity level of a SHACL shape, if declared with (
<code>sh:Info</code>, 
<code>sh:Warning</code>, or 
<code>sh:Violation</code>), can be included in the violation result 
(see Section <a href="bookHtml012.html#ch050severity">5.6.5</a>).</p><p>ShEx does not have rich violation reporting, but it can provide related functionality.
The result of the validation process is a shape map which contains information about the nodes that conform to a shape or not. 
Every violation can be viewed as an entry showing the focus node and the shape that failed. 
ShEx processors usually enrich these entries with further information.
As shapes in ShEx can contain arbitrary 
annotations (see Section <a href="bookHtml011.html#ch040Annotations">4.7.5</a>), these annotations can be included in the results.</p><p>In simple and top-level shape definitions, SHACL provides 
richer and granular violation reporting for each individual constraint that failed. 
However, violations on nested constraints as formed using 
<code>sh:node</code>, 
<code>sh:and</code>, 
<code>sh:or</code>, 
<code>sh:xone</code>, or 
<code>sh:qualifiedValueShape</code>, report only which nested constraint failed (“
<code>sh:node</code> failed”) without detailing why.
Implementations could report that information by means of the <span class="c008"><span class="c012"><span class="c011">sh:detail</span></span></span> property, but that would be an implementation dependent feature.
Also, as a result of validation ShEx produces a Result Map associating nodes
with shapes (either validated or non-validated) while SHACL has no comparable feature.</p>
<h2 class="section" id="sec204">7.8  Default Cardinalities</h2>
<p>
<a id="ch7.sec8"></a></p><p>If no cardinality is declared, ShEx assumes the cardinality to be 
<code>{1</code><code>,1</code><code>}</code> while SHACL assumes 
<code>{0</code><code>,</code><code>*}</code>. </p><div class="example"><div class="theorem"><span class="c014">Example 168</span>  <em>Comparing cardinalities in ShEx and SHACL</em><p><em>The following ShEx schema declares that nodes conforming to </em><em>
</em><code><em>:UserShape</em></code><em> must have one </em><em>
</em><code><em>schema:name</em></code><em> and one </em><em>
</em><code><em>schema:givenName</em></code><em>.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012">      </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:givenName</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>The following SHACL shapes graph declares that if there is a </em><em>
</em><code><em>schema:name</em></code><em> then it must have datatype </em><em>
</em><code><em>xsd:string</em></code><em>, and the same for </em><em>
</em><code><em>schema:givenName</em></code><em>:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShape</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:givenName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] .</span></em></td></tr>
</table><p><em>Given the following data:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:alice</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012">      </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Alice Cooper"</span></em></span></span></em><em><span class="c012">; #\</span></em><em><span class="c012"><span class="c007">Passes</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> - </span></em><em><span class="c012"><span class="c007">ShEx</span></span></em><em><span class="c012">}*)</span></em><em><span class="c012">
</span></em><em><span class="c012">       </span></em><em><span class="c012"><span class="c007">schema:givenName</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Alice"</span></em></span></span></em><em><span class="c012"> .       #\</span></em><em><span class="c012"><span class="c007">Passes</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> - </span></em><em><span class="c012"><span class="c007">SHACL</span></span></em><em><span class="c012">}*)</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:bob</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:givenName</span></span></em><em><span class="c012">   </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Robert"</span></em></span></span></em><em><span class="c012"> ;      #\</span></em><em><span class="c012"><span class="c007">Fails</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012">  - </span></em><em><span class="c012"><span class="c007">ShEx</span></span></em><em><span class="c012">}*)</span></em><em><span class="c012">
</span></em><em><span class="c012">     </span></em><em><span class="c012"><span class="c007">foaf:age</span></span></em><em><span class="c012">           23 .            #\</span></em><em><span class="c012"><span class="c007">Passes</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> - </span></em><em><span class="c012"><span class="c007">SHACL</span></span></em><em><span class="c012">}*)</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:carol</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012"> 345 ;                #\</span></em><em><span class="c012"><span class="c007">Fails</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> - </span></em><em><span class="c012"><span class="c007">ShEx</span></span></em><em><span class="c012">}*)</span></em><em><span class="c012">
</span></em><em><span class="c012">       </span></em><em><span class="c012"><span class="c007">schema:givenName</span></span></em><em><span class="c012"> 346 .           #\</span></em><em><span class="c012"><span class="c007">Fails</span></span></em><em><span class="c012">{</span></em><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> - </span></em><em><span class="c012"><span class="c007">SHACL</span></span></em><em><span class="c012">}*)</span></em></td></tr>
</table></div></div><p>
The difference in results is based on the difference between the ShEx and SHACL points of view.
In ShEx, a triple expression makes explicit which triples involving the focus node should be found in the graph, and specifying a cardinality may require several such triples.
The absence of cardinality means one triple.
In SHACL, a shape is a conjunction of constraints.
A cardinality constraint is used to constrain the number of allowed triples of a given kind, and
the absence of cardinality means no constraint on the number of triples allowed.</p>
<h2 class="section" id="sec205">7.9  Property Paths</h2>
<p> 
<a id="ch7.sec9"></a></p><p><a id="hevea_default829"></a>
SHACL property shapes can use a subset of SPARQL 1.1 property paths as 
values for 
<br>

<code>sh:path</code>. 
In this way, SHACL leverages on the expressiveness of SPARQL property paths to define constraints. </p><p>ShEx does not support arbitrary property paths—only direct and inverse predicates.
However, it is easy to emulate this SHACL behavior using nested shapes or recursion.</p><div class="example"><div class="theorem"><span class="c014">Example 169</span>  <em>Comparing paths in SHACL and ShEx</em><p><em>The following SHACL declaration:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:GrandParent</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> [ </span></em><em><span class="c012">sh:zeroOrMorePath</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:knows</span></em><em><span class="c012">] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:class</span></em><em><span class="c012"> </span></em><em><span class="c012">:Person</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> (</span></em><em><span class="c012">schema:child</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:child</span></em><em><span class="c012"> ) ;</span></em><em><span class="c012">
</span></em><em><span class="c012">        </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:class</span></em><em><span class="c012"> </span></em><em><span class="c012">:GrandChild</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">.</span></em></td></tr>
</table><p><em>can be defined in ShEx as: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:GrandParent</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:knows</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:PersonKnown</span></span></em><em><span class="c012">*;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:child</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012"><span class="c007">schema:child</span></span></em><em><span class="c012"> { </span></em><em><span class="c012"><span class="c007">a</span></span></em><em><span class="c012"> [ </span></em><em><span class="c012"><span class="c007">:GrandChild</span></span></em><em><span class="c012"> ] }</span></em><em><span class="c012">
</span></em><em><span class="c012"> }</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:PersonKnown</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">a</span></span></em><em><span class="c012"> [ </span></em><em><span class="c012"><span class="c007">:Person</span></span></em><em><span class="c012"> ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:knows</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:PersonKnown</span></span></em><em><span class="c012">*</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table></div></div>
<h2 class="section" id="sec206">7.10  Recursion</h2>
<p>
<a id="ch7.sec10"></a></p><p>ShEx supports the definition of cyclic data models with recursive shapes 
(see Section <a href="bookHtml011.html#ch040%3ACyclicReferences">4.7.2</a>) while
the processing of recursive shapes is undefined in SHACL 
(see Section <a href="bookHtml012.html#050SHACLRecursion">5.12.1</a>). 
However, some recursion cases can be handled in SHACL through SHACL property paths.</p><div class="example"><div class="theorem"><span class="c014">Example 170</span>  <em>Recursion</em><p><em>The following shape declares a recursive </em><em>
</em><code><em>:UserShape</em></code><em> as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">IRI</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:knows</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">@:UserShape</span></span></em><em><span class="c012">*</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>Nodes that conform to </em><em>
</em><code><em>:UserShape</em></code><em> must be IRIs and can have zero or more </em><em>
</em><code><em>schema:knows</em></code><em> arcs whose values must all conform to </em><em>
</em><code><em>:UserShape</em></code><em>. </em></p><p><em>A direct translation to SHACL would be: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShapeRecursion</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;   </span></em><span class="c012"><em><span class="c012"># This definition is recursive *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:knows</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:node</span></em><em><span class="c012"> </span></em><em><span class="c012">:UserShapeRecursion</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>However, recursion in SHACL is undefined and not all SHACL processors may handle that definition in the same way. 
The specification leaves recursion as an implementation-dependent feature.</em></p><p><em>One possible solution is to add target declarations to the shape to trigger the validation against them. 
A typical solution is to use </em><em>
</em><code><em>rdf:type</em></code><em> declarations as we saw in 
Section </em><a href="bookHtml012.html#050SHACLRecursion"><em>5.12.1</em></a><em>. 
In this case, we could also use </em><em>
</em><code><em>sh:targetSubjectsOf</em></code><em> like:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShapeRecursion</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:targetSubjectsOf</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:knows</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:knows</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:class</span></em><em><span class="c012"> </span></em><em><span class="c012">:User</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>Now, every node that is a subject of </em><em>
</em><code><em>schema:knows</em></code><em> must conform to that shape. </em></p><p><em>This solution may not be realistic in general. 
In this case, for example, we are forcing every node that is a subject of </em><em>
</em><code><em>schema:knows</em></code><em> to conform to </em><em>
</em><code><em>:UserShape</em></code><em> and in other contexts, this could be too restrictive. 
The same situation happens if we use </em><em>
</em><code><em>sh:targetClass</em></code><em> declarations.</em></p><p><em>Another approach to emulate recursive behavior is to use property paths. 
For example:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShape</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> [ </span></em><em><span class="c012">sh:zeroOrMorePath</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:knows</span></em><em><span class="c012">] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>In this case, every node that is related by property </em><em>
</em><code><em>schema:knows</em></code><em> zero or more times with the focus node, must be an IRI. 
With this solution, there may be other nodes that are subjects of </em><em>
</em><code><em>schema:knows</em></code><em> but do not need to conform to </em><em>
</em><code><em>:UserShape</em></code><em>.</em></p><p><em>In Section </em><a href="bookHtml012.html#ch050RecursionPropertyPaths"><em>5.12.1</em></a><em>, we described more advanced alternatives for using SHACL property paths as an alternative to recursion.
</em></p></div></div>
<h2 class="section" id="sec207">7.11  Property Pair Constraints and Uniqueness</h2>
<p>
<a id="ch7.sec11"></a></p><p>Property pair constraints in SHACL can be used to compare 
current values with values from another path, checking if they are equal, different or less than them (see Section <a href="bookHtml012.html#ch050propertyPairConstraints">5.14</a>). </p><p>ShEx 2.0 does not have the concept of property pair constraints,
though this possibility is being studied to be included in future versions.</p><div class="example"><div class="theorem"><span class="c014">Example 171</span>  <em>Example with property pair constraints</em><p><em>The following shapes graph declares that nodes conforming to </em><em>
</em><code><em>:UserShape</em></code><em> must fulfil the constraint that </em><em>
</em><code><em>schema:givenName</em></code><em> is equal to </em><em>
</em><code><em>foaf:firstName</em></code><em> and different from </em><em>
</em><code><em>schema:lastName</em></code><em>, and that </em><em>
</em><code><em>schema:birthDate</em></code><em> must be less than </em><em>
</em><code><em>:loginDate</em></code><em>.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:UserShape</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:givenName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:disjoint</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:lastName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">foaf:firstName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:equals</span></em><em><span class="c012">   </span></em><em><span class="c012">schema:givenName</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">schema:birthDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012"> </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:lessThan</span></em><em><span class="c012"> </span></em><em><span class="c012">:loginDate</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] .</span></em></td></tr>
</table><p><em>The previous example could be written in a future version of ShEx as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:UserShape</span></span></em><em><span class="c012"> {                                 # </span></em><em><span class="c012"><span class="c007">Not</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">supported</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">in</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">ShEx</span></span></em><em><span class="c012"> 2.0</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">givenName</span></span></em><em><span class="c012">&gt; </span></em><em><span class="c012"><span class="c007">schema:givenName</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">firstName</span></span></em><em><span class="c012">&gt; </span></em><em><span class="c012"><span class="c007">schema:firstName</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">birthDate</span></span></em><em><span class="c012">&gt; </span></em><em><span class="c012"><span class="c007">schema:birthDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">loginDate</span></span></em><em><span class="c012">&gt; </span></em><em><span class="c012"><span class="c007">:loginDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">givenName</span></span></em><em><span class="c012">&gt; =  </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">firstName</span></span></em><em><span class="c012">&gt; ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">givenName</span></span></em><em><span class="c012">&gt; != </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">lastName</span></span></em><em><span class="c012">&gt; ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">birthDate</span></span></em><em><span class="c012">&gt; &lt;  </span></em><em><span class="c012"><span class="c007">$</span></span></em><em><span class="c012">&lt;</span></em><em><span class="c012"><span class="c007">loginDate</span></span></em><em><span class="c012">&gt;</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table></div></div><p><a id="hevea_default830"></a>
One constraint often required is the ability to declare unique keys. 
Unique keys are combinations of values that must be unique in a given scope.
The scope can be the entire graph or a focus node. 
One example of a unique constraint for an entire graph is to require that there be no pair of identical values for the properties 
<code>schema:givenName</code> and 
<code>schema:lastName</code>. 
One example of a unique constraint with a focus node scope would be to require that each node not have two values of 
<code>rdfs:label</code> with the same language tag.</p><p>Neither SHACL nor ShEx 2.0 support unique keys in general, although they are supported by OWL 2.
<a id="hevea_default831"></a>
SHACL Core offers the 
<code>sh:uniqueLang</code> constraint to say that there can be no more than one literal for each language tag 
(see Section <a href="bookHtml012.html#ch050UniqueLang">124</a>).
Other constraints can be defined using SHACL-SPARQL.
<a id="hevea_default832"></a>
In the case of ShEx, there is a proposal to add a 
<code>UNIQUE</code> keyword to the language, with the scope and the list of predicates that must be unique as parameters.</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012"><span class="c007">:UserShape</span></span><span class="c012"> {                                 # </span><span class="c012"><span class="c007">Not</span></span><span class="c012"> </span><span class="c012"><span class="c007">supported</span></span><span class="c012"> </span><span class="c012"><span class="c007">in</span></span><span class="c012"> </span><span class="c012"><span class="c007">ShEx</span></span><span class="c012"> 2.0</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">schema:givenName</span></span><span class="c012"> </span><span class="c012"><span class="c007">xsd:string</span></span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">schema:lastName</span></span><span class="c012"> </span><span class="c012"><span class="c007">xsd:string</span></span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">UNIQUE</span></span><span class="c012">(</span><span class="c012"><span class="c007">schema:givenName,</span></span><span class="c012"> </span><span class="c012"><span class="c007">schema:lastName</span></span><span class="c012">)</span><span class="c012">
</span><span class="c012">}</span></td></tr>
</table>
<h2 class="section" id="sec208">7.12  Repeated Properties</h2>
<p> 
<a id="ch7.sec12"></a></p><p>ShEx allows multiple constraints on triples involving the focus nodes with the same property to be defined.
This feature is called repeated properties as explained in 
Section <a href="bookHtml011.html#ch040.RepeatedPropertiesSection">4.6.7</a>.
In SHACL, repeated properties behave conjunctively, which means that all constraints applied to properties with the same 
<code>sh:path</code> must be satisfied. 
The typical SHACL pattern of: </p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:Shape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">:p1</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012"><em><span class="c012">#...constraints on :p1... </span></em></span><span class="c012">
</span><span class="c012">  ];</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">:p2</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012"><em><span class="c012">#...constraints on :p2... </span></em></span><span class="c012">
</span><span class="c012">  ];</span><span class="c012">
</span><span class="c012">  ...</span></td></tr>
</table><p>must be changed if we want 
<code>:p1</code> and 
<code>:p2</code> to be the same property, only with different values. 
A direct translation of that pattern to:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:Shape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">:p</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012"><em><span class="c012"># ...constraints on :p... </span></em></span><span class="c012">
</span><span class="c012">  ];</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">:p</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012"><em><span class="c012">#...other constraints on :p... </span></em></span><span class="c012">
</span><span class="c012">  ];</span><span class="c012">
</span><span class="c012">  ...</span></td></tr>
</table><p>means that all constraints apply to the path 
<code>:p</code> conjunctively.</p><div class="example"><div class="theorem"><span class="c014">Example 172</span>  <em>Repeated properties in ShEx and SHACL</em><p><em>The following ShEx schema declares that a </em><em>
</em><code><em>:Person</em></code><em> has two parents, one with the value of </em><em>
</em><code><em>:isMale</em></code><em> </em><em>
</em><code><em>true</em></code><em> and the other with the value </em><em>
</em><code><em>:isFemale</em></code><em> </em><em>
</em><code><em>true</em></code><em>.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Person</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:parent</span></span></em><em><span class="c012"> { </span></em><em><span class="c012"><span class="c007">:isMale</span></span></em><em><span class="c012">   [ </span></em><em><span class="c012"><span class="c007">true</span></span></em><em><span class="c012"> ] }</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:parent</span></span></em><em><span class="c012"> { </span></em><em><span class="c012"><span class="c007">:isFemale</span></span></em><em><span class="c012"> [ </span></em><em><span class="c012"><span class="c007">true</span></span></em><em><span class="c012"> ] }</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>A direct translation of the ShEx schema into SHACL would be:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Person</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:node</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">:isMale</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">   ]</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:node</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">:isFemale</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1</span></em><em><span class="c012">
</span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">]</span></em><em><span class="c012">
</span></em><em><span class="c012">.</span></em></td></tr>
</table><p><em>However, this SHACL Shapes graph would only be satisfied by a node whose </em><em>
</em><code><em>schema:parent</em></code><em> value is both male and female.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:alice</span></em><em><span class="c012">   </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Person</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">         </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012"> </span></em><em><span class="c012">:bob</span></em><em><span class="c012"> ;    </span></em><span class="c012"><em><span class="c012"># \Passes{:Person in ShEx} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">         </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012"> </span></em><em><span class="c012">:carol</span></em><em><span class="c012"> .  </span></em><span class="c012"><em><span class="c012"># \Fails{:Person in SHACL} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:bob</span></em><em><span class="c012">     </span></em><em><span class="c012">:isMale</span></em><em><span class="c012">   </span></em><em><span class="c012">true</span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">:carol</span></em><em><span class="c012">   </span></em><em><span class="c012">:isFemale</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012"> .</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:dave</span></em><em><span class="c012">    </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">:Person</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">         </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012"> </span></em><em><span class="c012">:x</span></em><em><span class="c012"> .      </span></em><span class="c012"><em><span class="c012"># \Fails{:Person in ShEx} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">                                 </span></em><span class="c012"><em><span class="c012"># \Passes{:Person in SHACL} *)</span></em></span><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012">:x</span></em><em><span class="c012">       </span></em><em><span class="c012">:isMale</span></em><em><span class="c012">   </span></em><em><span class="c012">true</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">         </span></em><em><span class="c012">:isFemale</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012"> .</span></em></td></tr>
</table></div></div><p>As described in Section <a href="bookHtml012.html#ch050QualifiedValueShapes">5.12.2</a>, repeated properties can be handled in SHACL using 
<code>sh:qualifiedValueShape</code> but the definitions are more verbose.</p><div class="example"><div class="theorem"><span class="c014">Example 173</span>  <em>Repeated properties with qualified value shapes</em><p><em>The following declaration handles the previous example using qualified value shapes.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Person</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">                </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedValueShape</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">:isMale</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012">
</span></em><em><span class="c012">     ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedMinCount</span></em><em><span class="c012">   1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedMaxCount</span></em><em><span class="c012">   1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ];</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">                </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedValueShape</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">     </span></em><em><span class="c012">:isFemale</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">      </span></em><em><span class="c012">sh:hasValue</span></em><em><span class="c012"> </span></em><em><span class="c012">true</span></em><em><span class="c012">
</span></em><em><span class="c012">     ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedMinCount</span></em><em><span class="c012">   1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:qualifiedMaxCount</span></em><em><span class="c012">   1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">schema:parent</span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 2;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 2</span></em><em><span class="c012">
</span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">.</span></em></td></tr>
</table><p><em>Note that it requires to establish a count of the number of repeated properties allowed (in this case 2).
</em></p></div></div>
<h2 class="section" id="sec209">7.13  Exactly One and Alternatives</h2>
<p> 
<a id="ch060xoneAlternatives"></a>
<a id="ch7.sec13"></a></p><p>Data coherence minimizes defensive programming by providing predictable, logical data structures that 
must be used.
To take a trivial example, a data structure may offer a choice between different representations of a name
as in Example <a href="bookHtml011.html#ch040%3AexampleChoices">55</a> (for ShEx) and the corresponding Example <a href="bookHtml012.html#ch050exampleChoicesSHACL">131</a> (for SHACL).</p><p>Let’s change the constraint to require a combination of 

<code>foaf:firstName</code> and 
<code>foaf:lastName</code> or 

<code>foaf:givenName</code> and 
<code>foaf:familyName</code> or 

<code>schema:givenName</code> and 
<code>schema:familyName</code> 
where none of these properties can be mixed with the others. In ShEx, this can be declared as:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012"><span class="c007">:Person</span></span><span class="c012"> {</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">foaf:firstName</span></span><span class="c012"> . ; </span><span class="c012"><span class="c007">foaf:lastName</span></span><span class="c012"> . |</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">foaf:givenName</span></span><span class="c012"> . ; </span><span class="c012"><span class="c007">foaf:familyName</span></span><span class="c012"> . |</span><span class="c012">
</span><span class="c012"> </span><span class="c012"><span class="c007">schema:givenName</span></span><span class="c012"> . ; </span><span class="c012"><span class="c007">schema:familyName</span></span><span class="c012"> .</span><span class="c012">
</span><span class="c012">}</span></td></tr>
</table><p>Given the following data, 
<code>:alice</code> and 
<code>:bob</code> conform to 
<code>:Person</code> while 
<code>:carol</code> and 
<code>:dave</code> do not. 
In the case of 
<code>:dave</code>, it fails because the data meets one side of the disjunction 
and has some properties from the other side.</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:alice</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012"> </span><span class="c012"><span class="c012">"Alice"</span></span><span class="c012"> ;    </span><span class="c012"><em><span class="c012">#\Passes{:Person} *)</span></em></span><span class="c012">
</span><span class="c012">       </span><span class="c012">foaf:lastName</span><span class="c012"> </span><span class="c012"><span class="c012">"Cooper"</span></span><span class="c012"> .</span><span class="c012">
</span><span class="c012">
</span><span class="c012">:bob</span><span class="c012"> </span><span class="c012">schema:givenName</span><span class="c012"> </span><span class="c012"><span class="c012">"Robert"</span></span><span class="c012"> ;   </span><span class="c012"><em><span class="c012">#\Passes{:Person} *)</span></em></span><span class="c012">
</span><span class="c012">     </span><span class="c012">schema:familyName</span><span class="c012"> </span><span class="c012"><span class="c012">"Smith"</span></span><span class="c012"> .</span><span class="c012">
</span><span class="c012">
</span><span class="c012">:carol</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012"> </span><span class="c012"><span class="c012">"Carol"</span></span><span class="c012"> ;    </span><span class="c012"><em><span class="c012">#\Fails{:Person} *)</span></em></span><span class="c012">
</span><span class="c012">       </span><span class="c012">foaf:lastName</span><span class="c012"> </span><span class="c012"><span class="c012">"King"</span></span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">       </span><span class="c012">schema:givenName</span><span class="c012"> </span><span class="c012"><span class="c012">"Carol"</span></span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">       </span><span class="c012">schema:familyName</span><span class="c012"> </span><span class="c012"><span class="c012">"King"</span></span><span class="c012"> .</span><span class="c012">
</span><span class="c012">
</span><span class="c012">:dave</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012"> </span><span class="c012"><span class="c012">"Dave"</span></span><span class="c012"> ;      </span><span class="c012"><em><span class="c012">#\Fails{:Person} *)</span></em></span><span class="c012">
</span><span class="c012">      </span><span class="c012">foaf:lastName</span><span class="c012"> </span><span class="c012"><span class="c012">"Clark"</span></span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">      </span><span class="c012">schema:givenName</span><span class="c012"> </span><span class="c012"><span class="c012">"Dave"</span></span><span class="c012"> .</span></td></tr>
</table><p>A first attempt to model the example in SHACL could be:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:PersonShape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012">;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:targetClass</span><span class="c012"> </span><span class="c012">:Person</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:xone</span><span class="c012"> (</span><span class="c012">
</span><span class="c012"> [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:lastName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012"> [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012"> [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012">) .</span></td></tr>
</table><p>However, this SHACL shapes graph has a meaning different from the ShEx schema.
In this case, 
<code>:dave</code> conforms to 
<code>:Person</code> because it matches exactly one of the shapes (it has 
<code>foaf:firstName</code> and 
<code>foaf:lastName</code>) and does not match the other shapes. 
The intended meaning was that it should not have any of the other properties but it has 
<code>schema:givenName</code>. </p><p>As we described in Section <a href="bookHtml012.html#ch050exampleChoicesSHACL">131</a>, SHACL’s 
<code>sh:xone</code> does not check if there are partial matches in other shapes. A workaround to simulate ShEx behavior is to normalize the expression using a top-level disjunction whose shapes exclude the properties that are not desired. </p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:Person</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012">;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:or</span><span class="c012"> (</span><span class="c012">
</span><span class="c012">  [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">    ];</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:lastName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">     </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">    ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012"> [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:lastName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012"> [ </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:firstName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:lastName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 0</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:givenName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:familyName</span><span class="c012">;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1</span><span class="c012">
</span><span class="c012">   ];</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012"> )</span><span class="c012">
</span><span class="c012">.</span></td></tr>
</table><p>Although this approach solves the problem, more complex and nested shapes 
can increase the complexity and readability of SHACL shapes. </p>
<h2 class="section" id="sec210">7.14  Treatment of Closed Shapes</h2>
<p>
<a id="ch7.sec14"></a></p><p><a id="hevea_default833"></a>
ShEx has the 
<code>CLOSED</code> keyword to declare that a node must not have other properties beyond those declared in the shape.
<a id="hevea_default834"></a>
SHACL also has a 
<code>sh:closed</code> parameter to declare that a node conforming to a shape must not have other properties different from the properties declared in the shape.
Although they look similar, there are some differences due to the interaction of CLOSED with other language features.</p><p><a id="hevea_default835"></a>
When a SHACL shape is closed, SHACL processors only take into account the top-level properties that appear as the values of 
<code>sh:path</code> in property paths.
In this way, it is not the same if a shape is declared as a conjunction of property paths as when it is declared using 
<code>sh:and</code>. 
The following shape declares that nodes conforming to 
<code>:UserShape</code> must have properties 
<code>schema:name</code> and 
<code>schema:birthDate</code>. 
The declaration 
<code>sh:closed</code><code> </code><code>true</code> specifies that nodes conforming to 
<code>:UserShape</code> cannot have other properties.</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:closed</span><span class="c012"> </span><span class="c012">true</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:name</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:string</span><span class="c012">
</span><span class="c012"> ] ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:birthDate</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1 ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:date</span><span class="c012">
</span><span class="c012"> ]</span><span class="c012">
</span><span class="c012">.</span></td></tr>
</table><p>If we rewrite that example using a 
<code>sh:and</code> as:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:closed</span><span class="c012"> </span><span class="c012">true</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:and</span><span class="c012"> (</span><span class="c012">
</span><span class="c012">  [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:name</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:string</span><span class="c012">
</span><span class="c012">  ]</span><span class="c012">
</span><span class="c012">  [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:birthDate</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:maxCount</span><span class="c012"> 1 ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:date</span><span class="c012">
</span><span class="c012">  ]</span><span class="c012">
</span><span class="c012"> )</span><span class="c012">
</span><span class="c012">.</span></td></tr>
</table><p>then there will be no nodes satisfying the shape, as 
the two properties nested under 
<code>sh:and</code> are thus <em>hidden</em> and not taken into consideration by the 
<code>sh:closed</code> directive.</p><p><a id="hevea_default836"></a>
A solution in this case is to enumerate the properties that we allow using 
<code>sh:ignoredProperties</code>. 
In this case, one should add:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012">
</span><span class="c012">  </span><span class="c012">sh:ignoredProperties</span><span class="c012"> (</span><span class="c012">schema:name</span><span class="c012">
</span><span class="c012">                        </span><span class="c012">schema:birthDate</span><span class="c012">
</span><span class="c012">  )</span></td></tr>
</table><p>A similar situation could happen if we use more complex property paths. </p><p>For example, we may want to declare that users can have either 
<code>schema:name</code> or 
<code>foaf:name</code> using an alternative property path as:</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:closed</span><span class="c012"> </span><span class="c012">true</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:path</span><span class="c012"> [ </span><span class="c012">sh:alternativePath</span><span class="c012"> ( </span><span class="c012">schema:name</span><span class="c012"> </span><span class="c012">foaf:name</span><span class="c012"> ) ] ;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:minCount</span><span class="c012"> 1; </span><span class="c012">sh:maxCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">    </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:string</span><span class="c012"> ] ;</span><span class="c012">
</span><span class="c012">.</span></td></tr>
</table><p>As in the previous example, no node would conform to that shape because the closed declaration does not find direct properties in property paths.</p><p><a id="hevea_default837"></a>
There are two solutions: either to add a 
<code>sh:ignoredProperties</code> declaration enumerating all the properties as in previous example, or to add a property declaration for each predicate that specifies no cardinality, thus has no other effect.</p><table class="lstframe c015"><tr><td class="lstlisting"><span class="c012">:UserShape</span><span class="c012"> </span><span class="c012">a</span><span class="c012"> </span><span class="c012">sh:NodeShape</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:closed</span><span class="c012"> </span><span class="c012">true</span><span class="c012"> ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:path</span><span class="c012"> [ </span><span class="c012">sh:alternativePath</span><span class="c012"> ( </span><span class="c012">schema:name</span><span class="c012"> </span><span class="c012">foaf:name</span><span class="c012"> ) ] ;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:minCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:maxCount</span><span class="c012"> 1;</span><span class="c012">
</span><span class="c012">   </span><span class="c012">sh:datatype</span><span class="c012"> </span><span class="c012">xsd:string</span><span class="c012">
</span><span class="c012"> ] ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">schema:name</span><span class="c012"> ] ;</span><span class="c012">
</span><span class="c012"> </span><span class="c012">sh:property</span><span class="c012"> [ </span><span class="c012">sh:path</span><span class="c012"> </span><span class="c012">foaf:name</span><span class="c012"> ] ;</span><span class="c012">
</span><span class="c012">.</span></td></tr>
</table>
<h2 class="section" id="sec211">7.15  Stems and Stem Ranges</h2>
<p>
<a id="ch7.sec15"></a></p><p>ShEx supports the definition of stems and stem ranges when defining value sets 
(see Section <a href="bookHtml011.html#ch040ValueSets">4.5.4</a>).
SHACL does not have built-in support for stems or stem ranges. 
Stems and stem ranges could be emulated with 
<code>sh:pattern</code>, 
<code>sh:nodeKind</code>, and 
<code>sh:or</code>.</p><div class="example"><div class="theorem"><span class="c014">Example 174</span>  <em>IRI ranges example</em><p><em>The following example was described 
in Section </em><a href="bookHtml011.html#ch040%3AexampleIRIRanges"><em>44</em></a><em> and declared </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">prefix</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">codes:</span></span></em><em><span class="c012"> &lt;</span></em><em><span class="c012"><span class="c007">http:</span></span></em><em><span class="c012">//</span></em><em><span class="c012"><span class="c007">example</span></span></em><em><span class="c012">.</span></em><em><span class="c012"><span class="c007">codes</span></span></em><em><span class="c012">/&gt;</span></em><em><span class="c012">
</span></em><em><span class="c012">
</span></em><em><span class="c012"><span class="c007">:Product</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012"><span class="c007">:status</span></span></em><em><span class="c012"> [ </span></em><em><span class="c012"><span class="c007">codes:good</span></span></em><em><span class="c012">~ </span></em><em><span class="c012"><span class="c007">codes:bad</span></span></em><em><span class="c012">~ ]</span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table><p><em>A possible SHACL definition using regular expressions could be:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">:status</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:nodeKind</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:IRI</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">sh:or</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">     [ </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^http://example.codes/good"</span></em></span></em><em><span class="c012"> ]</span></em><em><span class="c012">
</span></em><em><span class="c012">     [ </span></em><em><span class="c012">sh:pattern</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"^http://example.codes/bad"</span></em></span></em><em><span class="c012">  ]</span></em><em><span class="c012">
</span></em><em><span class="c012">    )</span></em><em><span class="c012">
</span></em><em><span class="c012">  ] .</span></em></td></tr>
</table><p><em>Another possibility is to define a reusable constraint component in SHACL-SPARQL as:</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:StemConstraintComponent</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:ConstraintComponent</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:parameter</span></em><em><span class="c012"> [ </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">:stem</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:validator</span></em><em><span class="c012"> [ </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:SPARQLAskValidator</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:message</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Value does not have stem {$stem}"</span></em></span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:ask</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">""</span></em></span></em><em><span class="c012"><em><span class="c012">"</span></em><em><span class="c012">
</span></em><em><span class="c012">   ASK { FILTER (!isBlank($value) &amp;&amp;</span></em><em><span class="c012">
</span></em><em><span class="c012">      strstarts(str($value),str($stem)))</span></em><em><span class="c012">
</span></em><em><span class="c012">   }"</span></em></span></em><em><span class="c012"><em><span class="c012">""</span></em></span></em><em><span class="c012">
</span></em><em><span class="c012">] .</span></em></td></tr>
</table><p><em>which can be used as: </em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Product</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:path</span></em><em><span class="c012"> </span></em><em><span class="c012">:status</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:minCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:maxCount</span></em><em><span class="c012"> 1 ;</span></em><em><span class="c012">
</span></em><em><span class="c012">   </span></em><em><span class="c012">sh:or</span></em><em><span class="c012"> (</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">:stem</span></em><em><span class="c012"> &lt;</span></em><em><span class="c012">http:</span></em><em><span class="c012">//</span></em><em><span class="c012">example</span></em><em><span class="c012">.</span></em><em><span class="c012">codes</span></em><em><span class="c012">/</span></em><em><span class="c012">good</span></em><em><span class="c012">&gt;</span></em><em><span class="c012">
</span></em><em><span class="c012">    </span></em><em><span class="c012">:stem</span></em><em><span class="c012"> &lt;</span></em><em><span class="c012">http:</span></em><em><span class="c012">//</span></em><em><span class="c012">example</span></em><em><span class="c012">.</span></em><em><span class="c012">codes</span></em><em><span class="c012">/</span></em><em><span class="c012">bad</span></em><em><span class="c012">&gt;</span></em><em><span class="c012">
</span></em><em><span class="c012">   )</span></em><em><span class="c012">
</span></em><em><span class="c012"> .</span></em></td></tr>
</table></div></div><p>ShEx also has range exclusions that can declare values to exclude, either literal or specified with a stem (see <a href="bookHtml011.html#ch040%3AexampleIRIRangeExclusion">45</a>).
That feature is not part of SHACL Core and should be defined using SHACL-SPARQL.</p>
<h2 class="section" id="sec212">7.16  Annotations</h2>
<p>
<a id="ch7.sec16"></a></p><p>ShEx has the concept of annotations which can be attached to several constructs 
(see Section <a href="bookHtml011.html#ch040Annotations">4.7.5</a>). 
For example, the following ShEx schema attaches two annotations to each triple constraint.</p><div class="example"><div class="theorem"><span class="c014">Example 175</span>  <em>Annotations example in ShEx</em><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012"><span class="c007">:Person</span></span></em><em><span class="c012"> {</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:name</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:string</span></span></em><em><span class="c012">
</span></em><em><span class="c012">   // </span></em><em><span class="c012"><span class="c007">rdfs:label</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Name"</span></em></span></span></em><em><span class="c012">
</span></em><em><span class="c012">   // </span></em><em><span class="c012"><span class="c007">rdfs:comment</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Name of person"</span></em></span></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">schema:birthDate</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c007">xsd:date</span></span></em><em><span class="c012">
</span></em><em><span class="c012">   // </span></em><em><span class="c012"><span class="c007">rdfs:label</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"BirthDate"</span></em></span></span></em><em><span class="c012">
</span></em><em><span class="c012">   // </span></em><em><span class="c012"><span class="c007">rdfs:comment</span></span></em><em><span class="c012"> </span></em><em><span class="c012"><span class="c005"><em><span class="c012">"Date of birth"</span></em></span></span></em><em><span class="c012">
</span></em><em><span class="c012">}</span></em></td></tr>
</table></div></div><p>ShEx does not endorse or require the use of any specific annotation vocabulary. </p><p><a id="hevea_default838"></a>
<a id="hevea_default839"></a>
SHACL has non-validating constraint components (see Section <a href="bookHtml012.html#ch050NonValidating">5.15</a>), such as 
<code>sh:name</code> and 
<code>sh:description</code>, 
which are ignored by the SHACL processor during validation but can have special meaning for user interface generation.
It is also possible to add further informative triples to any constraint or component, such as 
<code>rdfs:label</code>. </p><div class="example"><div class="theorem"><span class="c014">Example 176</span>  <em>Annotations example in SHACL</em><p><em>The following ShEx schema declares a shape </em><em>
</em><code><em>:Person</em></code><em> using the non-validating properties </em><em>
</em><code><em>sh:name</em></code><em> and </em><em>
</em><code><em>sh_description</em></code><em> 
and the annotation </em><em>
</em><code><em>rdfs:label</em></code><em>.</em></p><table class="lstframe c015"><tr><td class="lstlisting"><em><span class="c012">:Person</span></em><em><span class="c012"> </span></em><em><span class="c012">a</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:NodeShape</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">        </span></em><em><span class="c012">schema:name</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012">    </span></em><em><span class="c012">xsd:string</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:name</span></em><em><span class="c012">        </span></em><em><span class="c012"><em><span class="c012">"Name"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:description</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Name of person"</span></em></span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">rdfs:label</span></em><em><span class="c012">     </span></em><em><span class="c012"><em><span class="c012">"Name"</span></em></span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ];</span></em><em><span class="c012">
</span></em><em><span class="c012"> </span></em><em><span class="c012">sh:property</span></em><em><span class="c012"> [</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:path</span></em><em><span class="c012">        </span></em><em><span class="c012">schema:birthDate</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:datatype</span></em><em><span class="c012">    </span></em><em><span class="c012">xsd:date</span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:name</span></em><em><span class="c012">        </span></em><em><span class="c012"><em><span class="c012">"BirthDate"</span></em></span></em><em><span class="c012"> ;</span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">sh:description</span></em><em><span class="c012"> </span></em><em><span class="c012"><em><span class="c012">"Birth date"</span></em></span></em><em><span class="c012">
</span></em><em><span class="c012">  </span></em><em><span class="c012">rdfs:label</span></em><em><span class="c012">     </span></em><em><span class="c012"><em><span class="c012">"BirthDate"</span></em></span></em><em><span class="c012">;</span></em><em><span class="c012">
</span></em><em><span class="c012"> ] .</span></em></td></tr>
</table></div></div><p>As we saw in Section <a href="bookHtml012.html#ch050NonValidating">5.15</a>, SHACL non-validating properties can be helpful for generating forms from SHACL definitions.</p><p>Although ShEx does not provide built-in non-validating properties, it would be possible to use annotations from other vocabularies, even from SHACL. </p>
<h2 class="section" id="sec213">7.17  Semantics and Complexity</h2>
<p>
<a id="ch7.sec17"></a></p><p>The ShEx semantic specification [<a href="bookHtml019.html#ShExSpec">81</a>] is based on mathematical concepts and 
has been proven to have a well founded semantics [<a href="bookHtml019.html#Boneva17">11</a>].
As we saw in Section <a href="bookHtml011.html#ch040ShExCyclicDependencies">4.8.3</a>, a restriction was imposed on the combination of recursion and negation 
to avoid ill-formed data models.</p><p>With regards to the complexity of the validation algorithm, ShEx semantics is based on a partitioning strategy where triples in the data are assigned to triple constraints in the schema and the matching algorithm must take into account that arcs in a graph are unordered. 
It is possible to construct schemas for which it is very expensive to find a mapping from RDF data triples to triple constraints that satisfies the schema. 
In practical schemas, this is rarely a concern as the search space is quite small, but certain mistakes in a schema can create a large search space.
The ShEx primer<sup><a id="text58" href="#note58">2</a></sup> contains some advices to improve performance.</p><blockquote class="quote">
"Accidentally duplicating many triple constraints in a shape causes the search space to explode. 
If a validation process takes a long time or a lot of memory, look for duplicated chunks of the schema.<p>For shapes with multiple triple constraints for the same predicate, try to minimize the overlap between the value expressions. 
For instance, if three types of inspection are necessary on a manufacturing checklist, use three different constraints for each of the inspection properties rather than requiring three different inspection properties with a value expression which is a union of all three types. 
This will make the validation process more efficient and will more effectively capture the business logic in the schema."
</p></blockquote><p>The SHACL Core semantics is defined in natural language with some non-normative SPARQL templates, while SHACL SPARQL depends on a SPARQL processor. 
Its complexity depends on the complexity of SPARQL, which can also be quite expensive, especially in the use of property paths.
As in the case of ShEx, it is also possible to declare shapes graphs that may consume a lot of time or memory. </p><p>Both ShEx and SHACL open the door for further research on optimizations and specialized implementations usable for big datasets. 
Validators could define language subsets with constructs that behave better when confronted with such datasets.
To our knowledge, current implementations have mainly been tested on in-memory data: 
separate RDF files, or relatively small <em>units of work</em> (transactions). 
An exception is RDFUnit, that supports the execution of SHACL directly on SPARQL
endpoints and thus, can theoretically scale along with the capabilities of
the SPARQL engine.
A lot of research remains to see how 
how very large (and not in-memory) data sets can be
efficiently validated with RDF shapes.</p><p>Benchmarks and testing tools are an essential step towards measuring the performance
of both languages as well as implementations.
One early attempt was to use the WebIndex dataset as a 
benchmark [<a href="bookHtml019.html#LabraLDQSemantics">57</a>].</p>
<h2 class="section" id="sec214">7.18  Extension Mechanisms</h2>
<p> 
<a id="ch070ComparingExtensionMechanism"></a>
<a id="ch7.sec18"></a></p><p>SHACL-SPARQL can be used to define both custom SPARQL-based constraints as well as reusable SPARQL-based constraint components 
(see Section <a href="bookHtml012.html#ch050SHACLSPARQLCOMPONENTS">5.16.2</a>).
As the constraint components are defined in SPARQL, any SPARQL compliant engine could potentially run them without requiring software updates for execution.
A SPARQL engine will be required in any case.
SHACL also provides SHACL-Javascript that can be used to write extensions 
(Section <a href="bookHtml012.html#ch050SHACLJS">5.20</a>).</p><p>SHACL-SPARQL allows the definition of new constraint components which can have parameters and can be reused in new contexts. 
It is expected that SHACL libraries of useful constraint components will be developed in the future.
For example, the <a href="http://datashapes.org/"><span class="c011">http://datashapes.org/</span></a> site contains a collection of some constraint components that extend SHACL Core.</p><p>ShEx has provisions for callout to arbitrary functions, called semantic actions, that are language-agnostic (see Section <a href="bookHtml011.html#ch040SemanticActions">4.10</a>). 
However, semantic actions cannot be used to create new reusable parametrizable shape expressions. 
This is considered an item for future work on ShEx.</p>
<h2 class="section" id="sec215">7.19  Conclusions and Outlook</h2>
<p>
<a id="ch7.sec19"></a></p><p>As of July 2017, it appears that ShEx and SHACL will evolve as two different specifications.
The design of SHACL prioritized the use of SPARQL as an execution engine and an extension mechanism for defining new constraint components, while ShEx was designed de novo to meet its use cases.
SHACL leverages a query language for validating sets of constraints, while 
validation schemas in the ShEx language are defined in terms of a grammar.</p><p>There is, however, a significant intersection between the two languages.
Many common use cases may be met with either language, although users should consider how the limitations of these languages apply to their current and future requirements.
In this book, we described and compared each formalism 
so that readers can assess which technology better fits their problems.</p><p><a id="hevea_default840"></a> <a id="hevea_default841"></a>
If we look for parallels in the XML ecosystem, 
ShEx is closer to RelaxNG or XML Schema, which provide structural definitions for XML documents.
SHACL is closer to Schematron, which defines rules or constraints on top of XPath
analogously to how SHACL defines constraints on top of SPARQL.
SHACL Core can capture simple structures, but more complex structures, with exclusive choices or repeated properties,
may require multiple inter-related constraints.</p><p><a id="hevea_default842"></a> <a id="hevea_default843"></a> <a id="hevea_default844"></a> <a id="hevea_default845"></a> <a id="hevea_default846"></a> <a id="hevea_default847"></a> <a id="hevea_default848"></a>
The two specifications currently have different implementation ecosystems.
ShEx has been implemented in a variety of programming languages and RDF libraries: Apache Jena, Ruby, Javascript, Haskell, and Python (see section <a href="bookHtml011.html#Ch04ShexImplementations">4.3</a>). 
In the case of SHACL, most implementations are based on Apache Jena and there is an implementation based on Javascript (see section <a href="bookHtml012.html#ch05SHACLImplementations">5.2</a>)
although there are some implementations appearing in other systems like rdf4j.
<a id="hevea_default849"></a> <a id="hevea_default850"></a> <a id="hevea_default851"></a>
Most ShEx implementations are non-commercial and have been developed mainly by 
individual projects. 
SHACL has a mature commercial implementation, bundled with the TopBraid suite of products, which
offers a rich user interface for editing SHACL-based data models. 
Although TopBraid is a commercial product, SHACL’s implementation is based on a separate open source library maintained by TopQuadrant.
SHACL is also integrated in the free edition of TopBraid Composer. </p><p>Both ShEx and SHACL open several lines for future work and research.</p><ul class="itemize"><li class="li-itemize"><span class="c014">Application to RDF vocabulary design.</span> 
When designing RDF vocabularies, it is a common practice to include an informal UML class diagram 
which represents the classes and their relationships. 
Some examples are the DCAT vocabulary [<a href="bookHtml019.html#DCAT">61</a>], the organization ontology [<a href="bookHtml019.html#Organization14">83</a>] and
the RDF Data Cube vocabulary [<a href="bookHtml019.html#RDFDataCube">24</a>].
Other vocabularies, such as the Provenance Ontology [<a href="bookHtml019.html#PROVO">59</a>] or the Annotation vocabulary [<a href="bookHtml019.html#WebAnnotation">87</a>], provide diagrams in similar styles.<p>In the future, these diagrams and vocabulary specifications can be backed by ShEx or SHACL specifications. 
A first step in that direction is seen where SHACL is used to capture the RDF Data Cube integrity constraints.<sup><a id="text59" href="#note59">3</a></sup> 
There is much room for innovations connecting these graphical representations to ShEx schemas or SHACL shapes graphs, such as shape visualization, or generating shapes from customized UML diagrams.</p></li><li class="li-itemize"><span class="c014">Efficient implementation of ShEx/SHACL processors.</span> 
It may be necessary to identify subsets of those languages that can be implemented efficiently, especially for handling big datasets. 
One problem with current implementations is that they work mainly in memory, limiting the size of datasets that can be processed.
One possible solution could be to have federated validators exchange intermediate validation results.</li><li class="li-itemize"><span class="c014">Shapes induction.</span> 
Given the recent emergence of schema languages, almost all existing RDF data has no associated schemas.
We can expect that schemas will be created for much of the existing data.
Deriving that automatically will greatly accelerate the availablity of schemas.
Some initial attempts are described in [<a href="bookHtml019.html#vanDam2015">99</a>] and  [<a href="bookHtml019.html#DanielFdez16">37</a>].
Such tools could become part of the validation process, producing schemas that are conservative enough to reject data patterns which are dubious because they occur very rarely in the examined data.<p>Given that there is already a large amount of RDF data that comes from structured sources such as SQL databases or Wikipedia info boxes,
derived schemas will likely reflect constraints native to the source format from which the data was converted or extracted.</p></li><li class="li-itemize"><span class="c014">Subgraph extraction.</span>
An instersting application of RDF Shapes is to be used as a driver for extracting subsets of a dataset that conform to specific shapes.
For example, one could want to extract all the persons in DBpedia that have an image and a birthdate.
Although this can be easily achieved for simple and independent shapes, complex schemas can be quite a challenging task.</li><li class="li-itemize"><span class="c014">Approximate validation.</span> 
An interesting topic for future research is to accommodate probabilistic approaches for RDF validation, which can check or predict typical graph structures around some nodes.</li><li class="li-itemize"><span class="c014">Optimization of RDF stores based on shapes.</span> 
RDF stores that know the shape of their RDF graphs can optimize their internal representations and increase the performance of 
SPARQL queries.</li><li class="li-itemize"><span class="c014">User interface generation from shapes.</span> 
Editing RDF by hand is usually an error-prone and non-user-friendly task. 
If the structure of the data is known, the editorial process can be improved.
Given that ShEx and SHACL Core define the properties that RDF nodes can have, specialized user interfaces and forms could be generated from those shapes to increase user friendliness.
As we described in Section <a href="bookHtml012.html#ch050NonValidating">5.15</a>, SHACL contains some built-in annotation properties which can help user interface generation from shapes graphs. 
ShEx also has support for any annotation properties, which in the future could also be used to 
generate rich user interfaces.</li><li class="li-itemize"><span class="c014">Generating Software Artifacts from Shapes.</span>
It may be possible to generate various software artifacts from appropriately extended shapes, such as: Object-RDF Mappinig
(ORM) layers, 
R2RML conversion scripts, 
JSONLD contexts and frames, 
etc.
</li><li class="li-itemize"><span class="c014">Schema transformation and mappings between data models.</span> 
One of the most frequent needs in computer science is to transform data based on some schema to data conforming to another schema.
These transformations are usually made by ad-hoc and error-prone procedural programs. 
Because shapes languages can capture the structures of the sources and targets of these transformations, they can be leveraged to define mappings.
ShEx Map,<sup><a id="text60" href="#note60">4</a></sup> an extension of ShEx, can be used to convert RDF data between schemas.</li><li class="li-itemize"><span class="c014">Integration between ShEx and SHACL.</span> 
Although ShEx and SHACL are two different approaches, both were designed to handle the general problem of RDF validation. 
ShEx shines in its support of recursion based on well-founded semantics, while SHACL shines in its support for SPARQL property paths
and other SPARQL features. 
As in the case of XML, where Schematron and RelaxNG can be used 
together [<a href="bookHtml019.html#Robertsson2004">84</a>], 
ShEx and SHACL could be combined in a project to leverage the advantages of each. <p>On the other hand, the underpinnings of ShEx and SHACL are not radically different.
One implementation, Shaclex,<sup><a id="text61" href="#note61">5</a></sup>
uses compatible parts of libraries to implement a processor for both SHACL and ShEx and is being extended to convert between subsets of the languages.</p></li><li class="li-itemize"><span class="c014">ShEx and SHACL best practices.</span> 
This book describes how ShEx and SHACL can be used to express both simple and complex constraints on RDF data.
It does not attempt to teach modeling, or product design, or the engineering skill of knowing when to define constraints 
and when to leave data less constrained.
While modeling and enterprise data management are covered by an extensive literature, the scale and breadth of the Semantic Web requires new formulations of well-known problems.</li></ul><p>ShEx and SHACL will play an important role in the future development of RDF and will be a core part of the Semantic Web tool set.
As more semantic data is generated, and more applications are needed to integrate and consume it, 
RDF validation will be a fundamental enabler for data quality and systems interoperability. </p>
<h2 class="section" id="sec216">7.20  Summary</h2>
<p>
<a id="ch7.sec20"></a></p><ul class="itemize"><li class="li-itemize">ShEx and SHACL can both be used to validate RDF.</li><li class="li-itemize">The expressiveness of ShEx and SHACL for common use cases is similar.</li><li class="li-itemize">ShEx is a W3C Community Group specification while SHACL Core and SHACL-SPARQL 
are a W3C Recommendation</li><li class="li-itemize">ShEx is schema-oriented, while SHACL is focused on defining constraints over RDF graphs.</li><li class="li-itemize">ShEx can be used with a compact syntax, a JSON-LD syntax, or any RDF syntax.
SHACL can be used with any RDF syntax, and a draft compact syntax has been proposed.</li><li class="li-itemize">ShEx has support for recursion and cyclic data models while recursion in SHACL is undefined.</li><li class="li-itemize">SHACL has support for arbitrary SPARQL property paths while ShEx has support only for incoming and outgoing arcs.</li><li class="li-itemize">Both ShEx and SHACL support violation reporting at the shape level.
For simple shapes, SHACL can further distinguish the violations per constraint,
as well as provide more violation metadata.
SHACL returns the violations in RDF using the Validation Report vocabulary while ShEx returns a shape map with all nodes that were validated, including the ones that pass validation while SHACL only the ones that failed.</li><li class="li-itemize">ShEx has a language agnostic extension mechanism called semantic actions while SHACL offers extensibility through SPARQL and JavaScript.</li></ul>
<h2 class="section" id="sec217">7.21  Suggested Reading</h2>
<p>
<a id="ch7.sec21"></a></p><ul class="itemize"><li class="li-itemize">A seminal paper comparing ShEx and SHACL in its early versions: <a href="bookHtml019.html#LabraValidatingDescribingDataPortalsArxivVersion2017">Labra Gayo, Prud’hommeaux, Solbrig, and
Boneva</a>,<a href="bookHtml019.html#LabraValidatingDescribingDataPortalsArxivVersion2017">2017</a> [<a href="bookHtml019.html#LabraValidatingDescribingDataPortalsArxivVersion2017">58</a>]</li><li class="li-itemize">Another paper comparing different RDF validation requirements: <a href="bookHtml019.html#Hartmann16">Hartmann, Zapilko, Wackerow, and
Eckert</a>,<a href="bookHtml019.html#Hartmann16">2016</a> [<a href="bookHtml019.html#Hartmann16">45</a>]</li></ul><p><a id="hevea_default852"></a> <a id="hevea_default853"></a>
</p>
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note57" href="#text57">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The complete list of rules is defined in <a href="https://www.w3.org/TR/shacl/\#syntax-rules"><span class="c011">https://www.w3.org/TR/shacl/\#syntax-rules</span></a>.</div></dd><dt class="dt-thefootnotes"><a id="note58" href="#text58">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">See: http://shex.io/shex-primer/</div></dd><dt class="dt-thefootnotes"><a id="note59" href="#text59">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">See: https://www.w3.org/2011/gld/validator/datacube.shapes.ttl</div></dd><dt class="dt-thefootnotes"><a id="note60" href="#text60">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">See: http://shex.io/extensions/Map/</div></dd><dt class="dt-thefootnotes"><a id="note61" href="#text61">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">See: http://labra.github.io/shaclex/</div></dd></dl>
<hr>
<a href="bookHtml013.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="bookHtml015.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>
